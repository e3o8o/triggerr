#!/usr/bin/env bun

/**
 * Auto-generation script for business-types.d.ts
 *
 * This script reads the database schema and generates TypeScript interfaces
 * that perfectly match the database structure. This ensures type safety
 * and prevents drift between database schema and TypeScript types.
 */

import { writeFileSync, readFileSync } from "fs";
import { resolve } from "path";

// Paths
const SCHEMA_PATH = resolve(__dirname, "../src/database/schema.ts");
const OUTPUT_PATH = resolve(
  __dirname,
  "../../shared/src/types/business-types.d.ts",
);

// Read schema file
const schemaContent = readFileSync(SCHEMA_PATH, "utf-8");

// Extract enum definitions
function extractEnums(content: string): Record<string, string[]> {
  const enumRegex = /export const (\w+) = pgEnum\("[\w_]+", \[([\s\S]*?)\]\);/g;
  const enums: Record<string, string[]> = {};

  let match;
  while ((match = enumRegex.exec(content)) !== null) {
    const enumName = match[1];
    const enumValues = match[2]
      .split(",")
      .map((val) => val.trim())
      .filter((val) => val.length > 0)
      .map((val) => {
        // Extract string value from quotes, remove comments
        const cleanVal = val.replace(/\/\/.*$/, "").trim();
        const quoted = cleanVal.match(/"([^"]+)"/);
        return quoted ? quoted[1] : cleanVal;
      })
      .filter((val) => val.length > 0);

    enums[enumName] = enumValues;
  }

  return enums;
}

// Generate TypeScript enum types
function generateEnumTypes(enums: Record<string, string[]>): string {
  const enumMappings = {
    providerStatusEnum: "ProviderStatus",
    providerCategoryEnum: "ProviderCategory",
    providerTierEnum: "ProviderTier",
    productStatusEnum: "ProductStatus",
    productCategoryEnum: "ProductCategory",
    policyStatusEnum: "PolicyStatus",
    coverageTypeEnum: "CoverageType",
    flightStatusEnum: "FlightStatus",
    escrowStatusEnum: "EscrowStatus",
    payoutStatusEnum: "PayoutStatus",
    escrowModelEnum: "EscrowModel",
    premiumReturnPolicyEnum: "PremiumReturnPolicy",
    escrowTypeEnum: "EscrowType",
    escrowPurposeEnum: "EscrowPurpose",
    revenueTypeEnum: "RevenueType",
    beneficiaryTypeEnum: "BeneficiaryType",
    endorsementTypeEnum: "EndorsementType",
    policyEventTypeEnum: "PolicyEventType",
  };

  let result = "";

  for (const [enumKey, typeName] of Object.entries(enumMappings)) {
    if (enums[enumKey]) {
      const values = enums[enumKey].map((val) => `"${val}"`).join(" | ");
      result += `export type ${typeName} = ${values};\n\n`;
    }
  }

  return result;
}

// Generate the main content
function generateBusinessTypes(): string {
  const enums = extractEnums(schemaContent);
  const enumTypes = generateEnumTypes(enums);

  return `/**
 * Auto-generated business types from database schema
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Generated by: packages/core/scripts/generate-business-types.ts
 * Source: packages/core/src/database/schema.ts
 *
 * To regenerate this file, run: bun run generate:types
 */

// ============================================================================
// ENUM TYPES (Auto-generated from schema)
// ============================================================================

${enumTypes}

// ============================================================================
// INTERFACE DEFINITIONS (Based on database schema)
// ============================================================================

/**
 * Insurance Provider interface matching the 'provider' table schema
 */
export interface InsuranceProvider {
  id: string;
  name: string;
  slug: string;
  category: ProviderCategory;
  status: ProviderStatus;
  tier: ProviderTier;
  description?: string;
  logoUrl?: string;
  websiteUrl?: string;
  supportEmail?: string;
  walletAddress: string;
  walletPrivateKey?: string; // Encrypted
  apiEndpoint?: string;
  webhookSecret?: string; // Encrypted
  commissionRate: string; // Decimal as string
  businessAddress?: string;
  businessRegistrationNumber?: string;
  payoutPreference?: {
    schedule: string;
    minimumAmount?: number;
  };
  preferredChain: string;
  linkedAirlineIcaoCode?: string;

  // Escrow Model Configuration
  escrowModel: EscrowModel;
  premiumReturnPolicy: PremiumReturnPolicy;
  collateralRequirement: string; // Decimal as string
  poolAddress?: string;
  poolMinimumBalance: string; // Decimal as string
  escrowConfiguration?: any; // JSONB field

  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Insurance Product interface matching the 'providerProduct' table schema
 */
export interface InsuranceProduct {
  id: string;
  providerId: string;
  name: string;
  description?: string;
  category: ProductCategory;
  status: ProductStatus;
  baseRate: string; // Decimal as string
  maxCoverage: string; // Decimal as string
  metadata?: any; // JSONB field
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Insurance Policy interface matching the 'policy' table schema
 */
export interface InsurancePolicy {
  id: string;
  userId: string;
  providerId: string;
  productId: string;
  flightId: string;
  status: PolicyStatus;
  coverageType: CoverageType;
  premiumAmount: string; // Decimal as string
  coverageAmount: string; // Decimal as string
  effectiveDate: Date;
  expiryDate: Date;
  purchaseDate: Date;
  flightDate: Date;
  delayThresholdMinutes: number;
  policyTerms?: any; // JSONB field
  verificationCode: string;
  escrowId?: string;
  payoutAmount?: string; // Decimal as string
  payoutDate?: Date;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Escrow Account interface matching the 'escrow' table schema
 */
export interface EscrowAccount {
  id: string;
  type: EscrowType;
  purpose: EscrowPurpose;
  status: EscrowStatus;
  userId?: string;
  policyId?: string;
  providerId?: string;
  totalAmount: string; // Decimal as string
  availableAmount: string; // Decimal as string
  reservedAmount: string; // Decimal as string
  escrowAddress: string;
  releaseConditions?: any; // JSONB field
  metadata?: any; // JSONB field
  expiresAt?: Date;
  releasedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Payout interface matching the 'payout' table schema
 */
export interface PolicyPayout {
  id: string;
  policyId: string;
  escrowId?: string;
  amount: string; // Decimal as string
  status: PayoutStatus;
  recipientAddress: string;
  transactionHash?: string;
  metadata?: any; // JSONB field
  processedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Revenue Record interface matching the 'revenue' table schema
 */
export interface RevenueRecord {
  id: string;
  type: RevenueType;
  amount: string; // Decimal as string
  currency: string;
  policyId?: string;
  providerId?: string;
  userId?: string;
  escrowId?: string;
  transactionHash?: string;
  blockchainNetwork?: string;
  feePercentage?: string; // Decimal as string
  netAmount?: string; // Decimal as string
  grossAmount?: string; // Decimal as string
  description?: string;
  metadata?: any; // JSONB field
  accountingPeriod?: string;
  reconciled: boolean;
  reconciledAt?: Date;
  transactionDate: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Flight Data interface matching the 'flight' table schema
 */
export interface FlightData {
  id: string;
  flightNumber: string;
  airlineIcaoCode: string;
  originAirportIataCode: string;
  destinationAirportIataCode: string;
  scheduledDepartureTime: Date;
  scheduledArrivalTime: Date;
  actualDepartureTime?: Date;
  actualArrivalTime?: Date;
  status: FlightStatus;
  aircraftTypeId?: string;
  delayMinutes?: number;
  metadata?: any; // JSONB field
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Quote interface matching the 'quote' table schema
 */
export interface InsuranceQuote {
  id: string;
  userId?: string;
  sessionId?: string;
  flightId: string;
  providerId: string;
  productId: string;
  coverageType: CoverageType;
  premiumAmount: string; // Decimal as string
  coverageAmount: string; // Decimal as string
  riskScore?: string; // Decimal as string
  delayThresholdMinutes: number;
  validUntil: Date;
  flightDate: Date;
  quoteData?: any; // JSONB field
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// ============================================================================
// UTILITY TYPES & LEGACY COMPATIBILITY
// ============================================================================

/**
 * Legacy type aliases for backward compatibility
 */
export type ClaimStatus =
  | "SUBMITTED"
  | "UNDER_REVIEW"
  | "APPROVED"
  | "REJECTED"
  | "PAID";

export type RiskLevel = "LOW" | "MEDIUM" | "HIGH" | "VERY_HIGH";

// ============================================================================
// TYPE GUARDS
// ============================================================================

export declare function isInsuranceProvider(obj: any): obj is InsuranceProvider;
export declare function isInsurancePolicy(obj: any): obj is InsurancePolicy;
export declare function isEscrowAccount(obj: any): obj is EscrowAccount;

// ============================================================================
// COMPLEX BUSINESS TYPES (Manual definitions for business logic)
// ============================================================================

/**
 * Risk multiplier for pricing calculations
 */
export interface RiskMultiplier {
  factor:
    | "AIRLINE_PUNCTUALITY"
    | "ROUTE_HISTORY"
    | "WEATHER_SEASON"
    | "AIRCRAFT_TYPE"
    | "TIME_OF_DAY";
  multiplier: number;
  description: string;
  dataSource?: string;
}

/**
 * Seasonal pricing factor
 */
export interface SeasonalFactor {
  season: "WINTER" | "SPRING" | "SUMMER" | "FALL";
  regions: string[];
  multiplier: number;
  effectivePeriod: {
    startMonth: number;
    endMonth: number;
  };
}

/**
 * Policy holder information
 */
export interface PolicyHolder {
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  address?: {
    street?: string;
    city?: string;
    state?: string;
    country: string;
    postalCode?: string;
  };
  preferences?: {
    communicationMethod: "EMAIL" | "SMS" | "BOTH";
    language: string;
    timezone: string;
  };
}

/**
 * Policy terms and conditions
 */
export interface PolicyTerms {
  delayThreshold: number;
  maxPayout: number;
  coverageIncludes: string[];
  exclusions: string[];
  claimRequirements: string[];
  cancellationPolicy: {
    allowedUntil: string;
    refundPercentage: number;
  };
  disputeResolution: {
    process: string;
    jurisdiction: string;
    arbitrationClause?: string;
  };
}

/**
 * Policy claim information
 */
export interface PolicyClaim {
  id: string;
  policyId: string;
  status: ClaimStatus;
  claimAmount: number;
  approvedAmount?: number;
  submittedAt: string;
  processedAt?: string;
  evidence: ClaimEvidence[];
  notes?: string;
  reviewedBy?: string;
}

/**
 * Claim evidence documentation
 */
export interface ClaimEvidence {
  type:
    | "FLIGHT_STATUS"
    | "DELAY_CONFIRMATION"
    | "BOARDING_PASS"
    | "RECEIPT"
    | "OTHER";
  description: string;
  fileUrl?: string;
  verificationStatus: "PENDING" | "VERIFIED" | "REJECTED";
  source?: "USER_UPLOADED" | "AUTOMATED_VERIFICATION" | "THIRD_PARTY";
}

/**
 * Escrow condition for release
 */
export interface EscrowCondition {
  type: "TIME_BASED" | "EVENT_BASED" | "MANUAL_APPROVAL" | "ORACLE_TRIGGER";
  description: string;
  parameter?: any;
  status: "PENDING" | "MET" | "FAILED";
  verifiedAt?: string;
}

/**
 * Market exchange rates
 */
export interface MarketRates {
  baseCurrency: string;
  exchangeRates: {
    [currency: string]: number;
  };
  lastUpdated: string;
  source: string;
}

/**
 * Risk assessment for flight
 */
export interface RiskAssessment {
  flightId: string;
  overallRisk: RiskLevel;
  riskScore: number;
  factors: {
    historicalDelays: {
      score: number;
      data: {
        onTimePercentage: number;
        averageDelayMinutes: number;
        worstDelayMinutes: number;
      };
    };
    weatherRisk: {
      score: number;
      data: {
        forecastConfidence: number;
        adverseConditionsProbability: number;
        historicalWeatherDelays: number;
      };
    };
    airlinePerformance: {
      score: number;
      data: {
        punctualityRating: number;
        operationalReliability: number;
        fleetAge: number;
      };
    };
    routeComplexity: {
      score: number;
      data: {
        airportCongestion: number;
        airspaceRestrictions: number;
        alternateAirports: number;
      };
    };
  };
  calculatedAt: string;
  validUntil: string;
}

/**
 * Competitive pricing analysis
 */
export interface CompetitivePricing {
  productId: string;
  marketPosition: "PREMIUM" | "COMPETITIVE" | "BUDGET";
  benchmarks: {
    providerId: string;
    providerName: string;
    premiumRate: number;
    coverageAmount: number;
    marketShare?: number;
  }[];
  recommendedPricing: {
    minRate: number;
    maxRate: number;
    optimalRate: number;
    reasoning: string[];
  };
  lastAnalyzed: string;
}

/**
 * Business performance metrics
 */
export interface BusinessMetrics {
  period: {
    start: string;
    end: string;
  };
  metrics: {
    totalRevenue: number;
    totalPremiums: number;
    totalPayouts: number;
    totalCommissions: number;
    policiesSold: number;
    claimsProcessed: number;
    claimApprovalRate: number;
    averageClaimProcessingTime: number;
    newCustomers: number;
    customerRetentionRate: number;
    customerSatisfactionScore: number;
    lossRatio: number;
    combinedRatio: number;
    reserveAdequacy: number;
  };
}

/**
 * Provider performance tracking
 */
export interface ProviderPerformance {
  providerId: string;
  period: {
    start: string;
    end: string;
  };
  performance: {
    volumeMetrics: {
      policiesUnderwritten: number;
      totalPremiumVolume: number;
      marketShare: number;
    };
    qualityMetrics: {
      claimApprovalRate: number;
      averageClaimProcessingTime: number;
      customerSatisfactionRating: number;
      disputeRate: number;
    };
    financialMetrics: {
      lossRatio: number;
      profitMargin: number;
      reserveRatio: number;
      paymentTimeliness: number;
    };
  };
  ranking: {
    overall: number;
    category: number;
    trend: "IMPROVING" | "STABLE" | "DECLINING";
  };
}

/**
 * Compliance record tracking
 */
export interface ComplianceRecord {
  providerId: string;
  jurisdiction: string;
  requirements: {
    licenseStatus: "ACTIVE" | "EXPIRED" | "SUSPENDED" | "PENDING";
    capitalRequirement: {
      required: number;
      current: number;
      compliant: boolean;
    };
    reserveRequirement: {
      required: number;
      current: number;
      compliant: boolean;
    };
    reportingCompliance: {
      lastReport: string;
      nextDue: string;
      status: "CURRENT" | "OVERDUE" | "SUBMITTED";
    };
  };
  auditHistory: {
    date: string;
    auditor: string;
    findings: string[];
    resolved: boolean;
  }[];
  lastUpdated: string;
}
`;
}

// Generate and write the file
const generatedContent = generateBusinessTypes();
writeFileSync(OUTPUT_PATH, generatedContent, "utf-8");

console.log(`âœ… Generated business-types.d.ts at: ${OUTPUT_PATH}`);
console.log(`ðŸ“Š File size: ${(generatedContent.length / 1024).toFixed(2)} KB`);
console.log(`ðŸ”„ Auto-generated from: ${SCHEMA_PATH}`);
